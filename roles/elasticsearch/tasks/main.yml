---
- name: check if certs exist
  ansible.builtin.stat: 'path=/etc/letsencrypt/live/{{ elasticsearch_hostname }}/privkey.pem'
  register: certfile

- name: fail if certs not present
  fail: 'msg="/etc/letsencrypt/live/{{ elasticsearch_hostname }}/privkey.pem not found"'
  when: not certfile.stat.exists

- name: set vars
  ansible.builtin.set_fact:
    elastic_running: false
    cluster_running: false

- name: check if elasticsearch already running
  ansible.builtin.uri:
    url: '{{ elasticsearch_uri }}/'
    user: '{{ elasticsearch_admin_user }}'
    password: '{{ elasticsearch_admin_password }}'
    validate_certs: false
    return_content: true
  register: elastic_response
  ignore_errors: true

- name: set a var if ES is already running
  ansible.builtin.set_fact:
    elastic_running: true
  when: "elastic_response.content is defined and 'cluster_name' in elastic_response.content"

- name: install elasticsearch rpm gpg key
  rpm_key: state=present key=https://artifacts.elastic.co/GPG-KEY-elasticsearch
  when: elastic_running is false

- name: install elasticsearch 8.x repository
  ansible.builtin.copy: src=elasticsearch-8.repo dest=/etc/yum.repos.d/elasticsearch.repo owner=root group=root mode=0644
  when: elasticsearch_version == 8 and elastic_running is false

- name: install elasticsearch and dependencies
  ansible.builtin.yum: name={{item}} state=latest
  with_items:
    - elasticsearch
  notify: update aide
  when: elastic_running is false

- name: Close public http port to all address when we have specific IP addresses configured
  ansible.posix.firewalld:
    port: '{{ elasticsearch_http_port }}/tcp'
    zone: "{{ elasticsearch_firewall_http_zone }}"
    permanent: true
    immediate: true
    state: disabled
  when: elasticsearch_firewall_http_allowed_source_ips | length | int > 0

- name: Open public http port to specific IP addresses
  ansible.posix.firewalld:
    zone: "{{ elasticsearch_firewall_http_zone }}"
    permanent: true
    immediate: true
    state: enabled
    rich_rule: "rule family=ipv4 source address={{ item }} port port={{ elasticsearch_http_port }} protocol=tcp accept"
  loop: "{{ elasticsearch_firewall_http_allowed_source_ips }}"
  when: elasticsearch_firewall_http_allowed_source_ips | length | int > 0

- name: Open public http port to all traffic
  ansible.posix.firewalld:
    port: '{{ elasticsearch_http_port }}/tcp'
    zone: "{{ elasticsearch_firewall_http_zone }}"
    permanent: true
    immediate: true
    state: enabled
  when: elasticsearch_firewall_http_allowed_source_ips | length | int == 0

- name: Close private transport port to all address when we have specific IP addresses configured
  ansible.posix.firewalld:
    port: '{{ elasticsearch_http_port }}/tcp'
    zone: "{{ elasticsearch_firewall_http_zone }}"
    permanent: true
    immediate: true
    state: disabled
  when: elasticsearch_firewall_transport_allowed_source_ips | length | int > 0

- name: Open private transport port to specific IP addresses
  ansible.posix.firewalld:
    zone: "{{ elasticsearch_firewall_transport_zone }}"
    permanent: true
    immediate: true
    state: enabled
    rich_rule: "rule family=ipv4 source address={{ item }} port port={{ elasticsearch_transport_port }} protocol=tcp accept"
  loop: "{{ elasticsearch_firewall_transport_allowed_source_ips }}"
  when: elasticsearch_firewall_transport_allowed_source_ips | length | int > 0

- name: Open private transport port to all traffic
  ansible.posix.firewalld:
    port: '{{ elasticsearch_transport_port }}/tcp'
    zone: "{{ elasticsearch_firewall_transport_zone }}"
    permanent: true
    immediate: true
    state: enabled
  when: elasticsearch_firewall_transport_allowed_source_ips | length | int == 0

- name: copy certs script
  ansible.builtin.template:
    src: es-certs.sh.j2
    dest: /usr/local/sbin/es-certs.sh
    owner: root
    group: root
    mode: '0755'

- name: run certs script
  ansible.builtin.shell: /usr/local/sbin/es-certs.sh

- name: copy elasticsearch.yml
  ansible.builtin.template:
    src: elasticsearch.yml.j2
    dest: /etc/elasticsearch/elasticsearch.yml
    owner: elasticsearch
    group: elasticsearch

- name: copy roles.yml
  ansible.builtin.template:
    src: roles.yml.j2
    dest: /etc/elasticsearch/roles.yml
    owner: elasticsearch
    group: elasticsearch

- name: uncomment initial master nodes
  ansible.builtin.replace:
    path: /etc/elasticsearch/elasticsearch.yml
    backup: true
    regexp: '^ *#cluster\.initial_master_nodes'
    replace: '  cluster.initial_master_nodes'
  when: elastic_running is false

- name: check cluster status
  ansible.builtin.uri:
    url: '{{ elasticsearch_uri }}/_cluster/health'
    user: '{{ elasticsearch_admin_user }}'
    password: '{{ elasticsearch_admin_password }}'
    validate_certs: false
    return_content: true
  register: cluster_response
  ignore_errors: true
  when: elastic_running is true

- name: comment out initial master nodes
  ansible.builtin.replace:
    path: /etc/elasticsearch/elasticsearch.yml
    backup: true
    regexp: '^cluster\.initial_master_nodes'
    replace: '#cluster.initial_master_nodes'
  when: "elastic_running is true and cluster_response.content is defined and 'cluster_name' in cluster_response.content"

- name: start elasticsearch on boot
  ansible.builtin.service: name=elasticsearch state=started enabled=yes
  when: elastic_running is false

- name: restart elasticsearch
  ansible.builtin.service: name=elasticsearch state=restarted
  when: elastic_running is true

- name: check if all seed hosts running
  ansible.builtin.uri:
    url: 'https://{{ item }}:{{ elasticsearch_http_port }}'
    validate_certs: false
    status_code: 401 #We can't authenticate without setting the root PW, but we can't set the root PW until the cluster is functional; if we get a 401 here, it means the node is running but rejected the request
  loop: '{{ elasticsearch_discovery_seed_hosts }}'

- name: set root password
  ansible.builtin.expect:
    command: '/usr/share/elasticsearch/bin/elasticsearch-reset-password -i -u {{ elasticsearch_admin_user }} --url="{{ elasticsearch_uri }}"'
    responses:
      confirm: "y"
      "password for": "{{ elasticsearch_admin_password }}"
  no_log: true

- name: check cluster status
  ansible.builtin.uri:
    url: '{{elasticsearch_uri}}/_cluster/health'
    user: '{{ elasticsearch_admin_user }}'
    password: '{{ elasticsearch_admin_password }}'
    validate_certs: false
    return_content: true
  register: cluster_response
  ignore_errors: true

- name: is cluster running?
  ansible.builtin.set_fact:
    cluster_running: true
  when: "cluster_response.content is defined and 'cluster_name' in cluster_response.content"

- name: create users
  ansible.builtin.uri:
    url: '{{ elasticsearch_uri }}/_security/user/{{ item.user }}'
    user: '{{ elasticsearch_admin_user }}'
    password: '{{ elasticsearch_admin_password }}'
    method: POST
    body_format: json
    validate_certs: false
    body:
      password: "{{ item.pass }}"
      roles: "{{ item.roles }}"
  when: cluster_running is true
  no_log: true
  loop: "{{ elasticsearch_users }}"

- name: comment out initial master nodes
  ansible.builtin.replace:
    path: /etc/elasticsearch/elasticsearch.yml
    backup: true
    regexp: '^ *cluster\.initial_master_nodes'
    replace: '#  cluster.initial_master_nodes'
  when: cluster_running is true
